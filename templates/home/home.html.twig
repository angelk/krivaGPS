{% extends "base.html.twig" %}

{% block content %}
    <div style="height: 50vh; min-height: 300px; width: 100%;" id="map"></div>
    <div class="">
        <input type="checkbox" id="map_show_mtb" checked /><label for="map_show_mtb">by bike</label>
        |
        <input type="checkbox" id="map_show_foot" checked /><label for="map_show_foot">by foot</label>
    </div>

    <hr>
    <div>
        <div>{{ "Latest tracks"|trans }}:</div>
        <ul>
            {% for track in latestTracks %}
                <li>
                    <a href="{{ path('gps-view', { id: track.slugOrId}) }}">
                        {% if track.name is empty %}
                            {{ track.id }}
                        {% else %}
                            {{ track.name }}
                        {% endif %}
                    </a>
                </li>
            {% endfor %}
        </ul>
    </div>

    <script>
        var mapOptions = {
            showByBike: true,
            showByFoot: true
        };

        var gpsColors = [
            'blue',
            'black',
            'indigo',
            'orange',
            'purple',
            'red',
        ];
        var map = L.map(
            'map',
            {
                gestureHandling: true
            }
        ).setView([42.15, 24.75], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        fullScreenControl = L.Control.extend({
            options: {
                position: 'topleft'
            },
            onAdd: function (map) {
                let container = L.DomUtil.create('div', 'leaflet-bar leaflet-control leaflet-control-custom');

                container.innerHTML = "&#9857;";
                container.title="Toggle full screen";

                container.style.backgroundColor = 'white';
                container.style.width = '32px';
                container.style.height = '32px';
                container.style.cursor = 'pointer';
                container.style['font-size'] = '31px';
                container.style['line-height'] = '31px';


                container.onclick = function() {
                    let currentHeight = document.getElementById('map').style.height;
                    console.log(currentHeight);

                    if (currentHeight === "90vh") {
                        document.getElementById('map').style.height='30vh';
                    } else {
                        document.getElementById('map').style.height='90vh';
                    }

                    // redraw map
                    window.dispatchEvent(new Event('resize'));
                };

                return container;
            },
        });

        map.addControl(new fullScreenControl());

        var loadedTracks = {};

        map.on('moveend', function() {
            var ajax = new XMLHttpRequest();
            ajax.onreadystatechange = function() {
                if (this.readyState != 4 || this.status != 200) {
                    return;
                }

                let responseAsJson = JSON.parse(this.responseText);

                var responseStatus = responseAsJson.status;

                if (responseStatus == 2) {
                    appNotification.error('Too many track found, please zoom in');
                    return;
                }

                if (responseStatus != 1) {
                    // unknown error
                    // @FIXME show error
                    return;
                }

                let tracksData = responseAsJson.data;

                for (let i = 0; i < tracksData.length; i++) {
                    let id = tracksData[i].id;
                    let slugOrId = tracksData[i].slugOrId;

                    if (loadedTracks[id]) {
                        continue;
                    }


                    var polylineCollection = [];
                    for (let j = 0; j < tracksData[i].points.length; j++) {
                        let points = tracksData[i].points[j];
                        let pointsAsPolyline = [];
                        for (let pointIndex = 0; pointIndex < points.length; pointIndex++) {
                            pointsAsPolyline.push([
                                points[pointIndex].lat,
                                points[pointIndex].lng
                            ]);
                        }

                        let polylineColor = gpsColors[Math.floor(Math.random()*gpsColors.length)];
                        let polyline = L.polyline(pointsAsPolyline, {color: polylineColor});
                        polylineCollection.push(polyline);
                        polyline.bindPopup('<a href="/{{ app.request.locale }}/gps/view/' + encodeURIComponent(slugOrId) + '">view details</a>');
                    }

                    let track = new AppTrack(map, polylineCollection);
                    track.setType(tracksData[i].type);

                    switch (track.getType()) {
                        case 1:
                            if (mapOptions.showByBike) {
                                track.show();
                            }
                            break;
                        case 2:
                            if (mapOptions.showByFoot) {
                                track.show();
                            }
                            break;
                        default:
                            track.show();
                    }

                    loadedTracks[id] = track;
                }
            };
            let url = '/{{ app.request.locale }}/gps/list';
            url += '/' + map.getBounds().getNorthEast().lat;
            url += '/' + map.getBounds().getNorthEast().lng;
            url += '/' + map.getBounds().getSouthWest().lat;
            url += '/' + map.getBounds().getSouthWest().lng;

            let postData = new FormData();
            let fetchedTracksIds = [];
            for (let key in loadedTracks) {
                fetchedTracksIds.push(key);
            }

            postData.append('skipTracks', fetchedTracksIds);

            ajax.open('POST', url);
            ajax.send(postData);
        });

        map.panTo(new L.LatLng(42.15, 24.75));
        if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
                map.panTo(new L.LatLng(position.coords.latitude, position.coords.longitude));
            });
        }

        // filter for track by type
        document.getElementById('map_show_mtb').addEventListener('click', function() {
            mapOptions.showByBike = this.checked;
            for(let trackId in loadedTracks) {
                let track = loadedTracks[trackId];
                if (track.getType() === 1) {
                    if (this.checked) {
                        track.show();
                    } else {
                        track.hide();
                    }
                }
            }
        });

        document.getElementById('map_show_foot').addEventListener('click', function() {
            mapOptions.showByFoot = this.checked;
            for(let trackId in loadedTracks) {
                let track = loadedTracks[trackId];
                if (track.getType() === 2) {
                    if (this.checked) {
                        track.show();
                    } else {
                        track.hide();
                    }
                }
            }
        });

    </script>
{% endblock %}
